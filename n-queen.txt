/* solve N-Queen problem in SimPL   */
/* author: wp StudentID: 1120379048 */
/*
Name: Wang Peng
ID: 1120379048

When I coped with Problem 4, I had some doubts about SimPL.
So in the  solution, I do some assumptions.

The Doubts:
  1. no type rule for "sequence expression", I assume that "e1, e2" have the same type as "e2".
  2. the return value of thenStat and elseStat must have the same type, and since there is no just ifStat, I use "sequence expression" to make thenStat and elseStat have the same type.
  3. no explicit "skip".
   I guess, you wants to use "()" has skip, but  "() (* nop - unit value *)", so it may be ambigous, so I use "skip" explicitly.
  4. no expression to declare a array, so the memory mode may be not so powerful
  5. no rule to define which expression can be the right value.
     for simplicity, I assume that (head list) can be a right-value.
*/

let 
/* define not eq */
 notEq = fun x -> fun y -> (x > y) or (x < y)
in

let 
/* do list[i] = v */
/* here we assumption: (head list) can be left value */
 assign = fun list -> fun v -> fun i ->
    if v = 0
    then
       (head list) = v
       ;
       list
    else
       assign list v (i-1)
in


/* judge whether nextQueen in the previous rows or not */ 
let 
    notRowConflict = fun pos -> fun q -> 
	         ( if pos = nil
			   then 
			       true 
			   else 
				  (notEq q < head pos) 
				   and ( notRowConflict (tail pos) q )
in				

/* judge whether nextQueen is confict with the previous queens in SW and SE or not */
/*
pos: a partial solution
q: the next queen's row
qi: the next queen's column index
li: pos's index
*/		
let notConflict = fun pos -> fun q -> fun qi -> li
            ( if pos = nil 
			  then 
			     true
			  else
			     notEq (q-(head pos)) (qi-li)          /* slop is 1 */
				 and notEq ((head pos)-q) (qi-li)     /* slop is -1 */
				 and notConflict (tail pos) q qi (li+1)
in

/* judge whether nextQueen is conflict with the previous queens or not */
/*
pos: a partial solution
q: the next queen's row
qc: the next queen's column
*/
let judge = fun pos -> fun q -> qc ->
            ( if pos = nil
			   then 
			      true
			   else
			      (notRowConflict pos q)
				  and (notConflict pos q qc 0)
in

/* solve the N-Queen problem */
/*
n: the number of queen
reuslt: [[pos] [pos] ... ]
pos: a solution
c: the column number
r: the row number
*/
let do_solve = fun n -> fun result -> fun pos -> fun c -> fun r ->
    if c = n
	then
	   result := result::pos
	else
	   while r < n
	   do 
	      if (judge pos r c)
          then
             assign pos r c/* TODO pos[c] = r; */
             do_solve n result pos 	(c+1) 0;
			 skip /*just for then and else have the same type*/
          else
             skip
          ;
          r := r+1		  
	   end
	   ;
	   result /* else statement must have the same type with if statement*/
in

/* initialize pos to [0, 0, 0, ... , 0] */
/* n: the queen number */
let initPos = fun n -> 
    if n = 0
	then
	   nil
	else
       0::initPos (n-1)
in	

/* 
define result to record every solution (If it appears at the beginning, it is global variable, and it is a good way)
*/
let 
result = nil
in

/* define position */
let 
 pos = nill
in   

/* N-Queen solver driver */
let
  queen = fun n ->
     pos = initPos n;
     do_solve n result pos 0 0
in
   queen 8
   
end end end end end end end end end end